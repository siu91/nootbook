<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>单元测试规范 - Siu 的笔记本</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../theme/style.css">
        

        

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../SUMMARY.html"><strong aria-hidden="true">1.</strong> 思考和总结🤔</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../mgmt/srcwd/index.html"><strong aria-hidden="true">1.1.</strong> 团队人员定义模型</a></li><li class="chapter-item "><a href="../../tech/backend/java-mem-mgmt/java-memory-management.html"><strong aria-hidden="true">1.2.</strong> 谈谈 Java 的内存管理（doing）</a></li></ol></li><li class="chapter-item expanded "><a href="../../SUMMARY.html"><strong aria-hidden="true">2.</strong> 架构和设计</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tech/project/AAA/index.html"><strong aria-hidden="true">2.1.</strong> DDD 实践：应用架构原型（doing）</a></li><li class="chapter-item "><a href="../../tech/backend/Java-Backend-Framework-Selection-Guide.html"><strong aria-hidden="true">2.2.</strong> Java 后端框架选型指南（doing）</a></li><li class="chapter-item "><a href="../../tech/project/PGHA/pg-ha-solution.html"><strong aria-hidden="true">2.3.</strong> PG HA 方案</a></li><li class="chapter-item "><a href="../../tech/project/kubesphere/基于Linux安装kubesphere3多节点集群(prod).html"><strong aria-hidden="true">2.4.</strong> KuberSphere 生产部署方案</a></li><li class="chapter-item "><a href="../../tech/project/lwpoc/lwpoc/架构/构建实时湖仓.html"><strong aria-hidden="true">2.5.</strong> 构建实时湖仓</a></li><li class="chapter-item "><a href="../../tech/project/cicd/index.html"><strong aria-hidden="true">2.6.</strong> CICD 设计</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tech/project/cicd/design/CICD架构.html"><strong aria-hidden="true">2.6.1.</strong> CI/CD 架构</a></li><li class="chapter-item "><a href="../../tech/project/cicd/design/Jenkins_Cluster.html"><strong aria-hidden="true">2.6.2.</strong> Jenkins 集群</a></li><li class="chapter-item "><a href="../../tech/project/cicd/design/多分支流水线设计.html"><strong aria-hidden="true">2.6.3.</strong> 多分支流水线设计</a></li><li class="chapter-item "><a href="../../tech/project/cicd/design/cec-jpl设计.html"><strong aria-hidden="true">2.6.4.</strong> cec-jpl 设计</a></li><li class="chapter-item "><a href="../../tech/project/cicd/design/数据库自动化.html"><strong aria-hidden="true">2.6.5.</strong> 数据库自动化</a></li><li class="chapter-item "><a href="../../tech/project/cicd/design/账号体系.html"><strong aria-hidden="true">2.6.6.</strong> 账号体系</a></li></ol></li><li class="chapter-item "><a href="../../tech/db/doris/doris-uniq-model/index.html"><strong aria-hidden="true">2.7.</strong> Doris Uniq 模型：分析场景下保证 Key 的唯一性</a></li></ol></li><li class="chapter-item expanded "><a href="../../SUMMARY.html"><strong aria-hidden="true">3.</strong> 最佳实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tech/bestpractices/How-to-write-an-outline-for-a-technical-solution/index.html"><strong aria-hidden="true">3.1.</strong> 怎样写一个技术方案的大纲</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tech/bestpractices/How-to-write-an-outline-for-a-technical-solution/template.html"><strong aria-hidden="true">3.1.1.</strong> 《技术解决方案》模版</a></li></ol></li><li class="chapter-item "><a href="../../tech/bestpractices/my-toolchain.html"><strong aria-hidden="true">3.2.</strong> 分享一下我的工具清单</a></li><li class="chapter-item "><a href="../../tech/bestpractices/sql性能测试工具的设计.html"><strong aria-hidden="true">3.3.</strong> sql 性能测试工具的设计</a></li><li class="chapter-item "><a href="../../tech/bestpractices/jrudf/doris-remote-udf.html"><strong aria-hidden="true">3.4.</strong> Doris Remote UDF 的开发和测试</a></li><li class="chapter-item "><a href="../../tech/bestpractices/禅道工作流.html"><strong aria-hidden="true">3.5.</strong> 禅道工作流</a></li><li class="chapter-item expanded "><a href="../../tech/bestpractices/单元测试规范.html" class="active"><strong aria-hidden="true">3.6.</strong> 单元测试规范</a></li><li class="chapter-item "><a href="../../tech/bestpractices/数据库自动化-Flyway使用规范.html"><strong aria-hidden="true">3.7.</strong> 数据库自动化：Flyway</a></li><li class="chapter-item "><a href="../../tech/bestpractices/语义化版本控制规范.html"><strong aria-hidden="true">3.8.</strong> 语义化版本</a></li><li class="chapter-item "><a href="../../tech/bestpractices/API设计规范.html"><strong aria-hidden="true">3.9.</strong> API设计规范</a></li><li class="chapter-item "><a href="../../tech/bestpractices/git-collaborative-development-tutorials/git协同开发指南.html"><strong aria-hidden="true">3.10.</strong> git 协同开发指南</a></li><li class="chapter-item "><a href="../../tech/bestpractices/code-review-guide-baseon-gitlab.html"><strong aria-hidden="true">3.11.</strong> Gitlab Code Review 指南</a></li><li class="chapter-item "><a href="../../tech/bestpractices/gitlab-issue-workflow.html"><strong aria-hidden="true">3.12.</strong> Gitlab Issue 工作流</a></li><li class="chapter-item "><a href="../../tech/bestpractices/Python编码规范.html"><strong aria-hidden="true">3.13.</strong> Python 编码规范</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Siu 的笔记本</h1>

                    <div class="right-buttons">
                        
                        
                        <a href="https://github.com/siu91/notebook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1><a class="header" href="#单元测试规范" id="单元测试规范">单元测试规范</a></h1>
<h3><a class="header" href="#一可衡量单测的编写应该是可以用具体的指标衡量的" id="一可衡量单测的编写应该是可以用具体的指标衡量的">一.可衡量：单测的编写应该是可以用具体的指标衡量的</a></h3>
<blockquote>
<p>1、单测通过率要求100%，行覆盖率要求50%。</p>
</blockquote>
<p>解释：通过率100%没啥好多说的，如果单测跑不通过，那不是单测有问题就是代码逻辑有问题。覆盖率的话可以根据具体的工程进行微调，建议不应小于40%，越底层的代码覆盖率应该越高，越新的代码覆盖率也应该越高。</p>
<blockquote>
<p>2、老代码有逻辑变更时，单测也应该做相应的变更。</p>
</blockquote>
<p>解释：这点的目的也是为了保证单测通过率100%。同时，这部分功能应该也属于改次功能的测试回归范围内。</p>
<blockquote>
<p>3、新业务提测前，必须保证老单测的通过率也保持100%。</p>
</blockquote>
<p>解释：这点的目的是为了防止回溯问题的出现。</p>
<h3><a class="header" href="#二独立性单测应该是独立且相互隔离的" id="二独立性单测应该是独立且相互隔离的">二.独立性：单测应该是独立且相互隔离的</a></h3>
<blockquote>
<p>4、一个单测只测试一个方法。</p>
</blockquote>
<p>解释：保证了单测的独立性。当单测出错的时候也能够明确知道是哪个方法出了问题。但这并不是说一个方法只对应一个单测，因为为了覆盖方法内的不同分支，我们可以为一个方法创建多个单测。</p>
<blockquote>
<p>5、单测不应该依赖于别的单测。</p>
</blockquote>
<p>解释：保证了单测的独立性。每个单测应该都能独立运行。不应该有A单测跑完才能跑B单测的情况。</p>
<blockquote>
<p>6、单测如果涉及到数据变更，必须进行回滚。</p>
</blockquote>
<p>解释：保证了单测的隔离性。如果单测运行后在数据库中产生了数据，那这些脏数据可能干扰测试同学的测试工作，且也可能影响别的单测的运行结果。</p>
<blockquote>
<p>7、单测应该测试目标方法本身的逻辑，对于被测试的方法内部调用的非私有方法应进行mock，推荐使用Mockito进行mock。</p>
</blockquote>
<p>解释：目标方法存在内部调用情况，进行mock可以屏蔽其他方法对目标方法的影响。这样保证了单测的独立性，一个单测只保证它测试的目标方法的逻辑正确性，而不应该受其内部调用方法的逻辑的影响，这部分应该是这些内部调用的方法对应的单测的责任。但是真实情况中，这一点是最难被严格执行，因为这样做就意味着需要对所有的方法都设计单测，比如a调用b调用c的情况，需要至少设计三个单测，而不能只对a设计单测来覆盖整个调用链。不过，这不正是单测的含义吗？对最小的逻辑单元——方法进行测试，如果对于一个调用链进行测试，更像是集成测试的范畴了。而且如果不这么做，我们就会违反上面的第4条“一个单测只测试一个方法”。只有一种情况例外，方法内部调用的是私有方法，这样的话是可以通过调用方的单测一并测试的，见下面的第13条“私有方法通过调用类的单测进行测试”。我们可以试想一种情况，当一个项目由很多人协同开发时，我怎么才能放心使用另一个人开发的方法？至少得提供单测吧，如果这个方法的测试是在其调用方的单测中的，那就没有直接对应的单测了，这样也就无法保证该方法是否被妥当测试过了。</p>
<h3><a class="header" href="#三规范性单测的编写需要符合一定规范" id="三规范性单测的编写需要符合一定规范">三.规范性：单测的编写需要符合一定规范</a></h3>
<blockquote>
<p>8、对实现类进行测试而非接口。</p>
</blockquote>
<p>解释：面向接口编程，面向实现测试。</p>
<blockquote>
<p>9、单测应该是无状态的。</p>
</blockquote>
<p>解释：即单测应该可以重复执行，且无论跑几次都应该保证通过率。比如有些方法会对当前时间进行判断，对于这类方法的单测也需根据当前时间的不同而进行不同的测试。</p>
<blockquote>
<p>10、覆盖范围应包括所有提供了逻辑的类：service层、manager层、自定义mapper等，甚至还有部分提供业务逻辑的controller层代码。</p>
</blockquote>
<p>解释：只要是提供了逻辑的就应该测试，不过个人并不建议在controller层提供业务逻辑，具体原因参考<a href="https://www.jianshu.com/p/654f4589eb8e">《设计之道－controller层的设计》</a>。</p>
<blockquote>
<p>11、覆盖范围不应包括自动生成的类：如MyBatis Generator生成的Mapper类、Example类，不应包括各种POJO（DO，BO，DTO，VO...），也不应包括无业务逻辑的controller类。</p>
</blockquote>
<p>解释：自动生成的类有啥好测的？POJO的getter/setter有啥好测的？没有提供业务逻辑的controller类有啥好测的？这些被排除的类应该在覆盖率统计中被剔除。</p>
<blockquote>
<p>12、私有方法通过调用类的单测进行测试。</p>
</blockquote>
<p>解释：因为私有方法在测试类内没法直接调用，除非使用反射。</p>
<blockquote>
<p>13、单测要覆盖到正常分支和异常分支，使用专门的异常测试属性junit（expected）/testng（expectedExceptions）。禁止使用try-catch。</p>
</blockquote>
<p>解释：很多同学的单测覆盖率不达标，就是因为只覆盖了正常的分支而遗漏的异常的分支。异常的测试和正常的一样重要，也就是该报错的时候就应该报错。有些同学为了达到单测的覆盖率和通过率的指标，在单测中使用try-catch，这也是不允许的，应该使用专门的异常测试注解。</p>
<blockquote>
<p>14、如果被测试的方法的逻辑体现在方法返回或成员变量中，则使用Assert断言验证该返回或成员变量。</p>
</blockquote>
<p>解释：如果一个方法的内部组装了一个返回值，或变更了一个成员变量，那么应该使用Assert来验证该返回值或成员变量是否符合预期。</p>
<p>比如下面的三个方法，前两个的逻辑都是体现在返回值上，后一个的逻辑体现在成员变量中。</p>
<pre><code class="language-dart">    /**
     * 逻辑体现在返回值
     *
     * @return
     */
    public String displayName() {
        String name = &quot;HangzhouZoo&quot;;
        return &quot;Zhejiang &quot; + name;
    }

    /**
     * 逻辑体现在返回值
     *
     * @return
     */
    public String luxuryShow() {
        String show = dog.run();
        return &quot;luxury!! &quot; + show;
    }

    /**
     * 逻辑体现在成员变量
     */
    public void close() {
        this.open = false;
    }
</code></pre>
<p>那么我们就可以使用Assert断言来测试这些逻辑：</p>
<pre><code class="language-java">    //逻辑在方法返回体现
    @Test
    public void displayName() {
        Assert.assertEquals(&quot;Zhejiang HangzhouZoo&quot;, hangzhouZoo.displayName());
    }

    //逻辑在方法返回体现
    @Test
    public void luxuryShow() {
        when(dog.run()).thenReturn(&quot;dog show&quot;);
        Assert.assertEquals(&quot;luxury!! dog show&quot;, hangzhouZoo.luxuryShow());
    }

    //逻辑在成员变量中体现
    @Test
    public void close() {
        Assert.assertTrue(hangzhouZoo.isOpen());
        hangzhouZoo.close();
        Assert.assertFalse(hangzhouZoo.isOpen());
    }
</code></pre>
<blockquote>
<p>16、如果被测试的方法的逻辑体现在内部的方法调用行为本身，则使用Mockito的verify验证内部方法调用的情况。</p>
</blockquote>
<p>解释：有些方法的内部根据不同的条件会调用不同的方法，则应该验证该方法的调用是否符合预期。Mockito的verify可以验证被mock的方法是否调用了，甚至可以验证方法调用的次数。</p>
<p>比如下面这个方法有三分条件分支，分支一抛出异常，分支二调用内部方法，分支三组装返回值。</p>
<pre><code class="language-java">    /**
     * 逻辑体现在异常、方法调用行为和返回值
     *
     */
    @Override
    public String show(Animal animal) throws ZooException {
        if (animal instanceof Tiger) {
            throw new ZooException(&quot;tiger is not allowed&quot;);
        } else if (animal instanceof Dog) {
            return animal.run();
        } else {
            return &quot;only dogs here&quot;;
        }
    }
</code></pre>
<p>其中分支二的逻辑就体现在方法调用的行为上，我们可以通过verify来验证方法是否如预期一样调用，也可使用times验证方法调用的次数。</p>
<pre><code class="language-dart">    //被测试的方法的逻辑体现在内部方法的调用行为本身
    @Test
    public void show() throws Exception {
        when(dog.run()).thenReturn(&quot;dog run&quot;);
        hangzhouZoo.show(dog);
        //验证方法被调用过了
        verify(dog).run();
        //也可以通过times参数来验证方法具体被调用的次数
        verify(dog, times(1)).run();
        //验证另一个分支，逻辑体现在返回值
        Assert.assertEquals(&quot;only dogs here&quot;, hangzhouZoo.show(new Cat()));
    }
</code></pre>
<p>当然，还记得第13条“异常分支也需要测试么”，我们还需要写一个单测来覆盖异常分支：</p>
<pre><code class="language-dart">    //测试异常分支
    @Test(expected = ZooException.class)
    public void showForEx() throws Exception {
        hangzhouZoo.show(new Tiger());
    }
</code></pre>
<blockquote>
<ol>
<li>如果被测试的方法的逻辑体现在内部方法调用的参数中，即方法的逻辑用于构建内部调用方法的参数，则使用Mockito的verify验证内部方法调用的参数。</li>
</ol>
</blockquote>
<p>解释：有些方法的内部会组装一个对象，然后将这个对象作为参数传入另一个内部方法。使用Mockito的verify可以验证被mock的方法被调用的参数。如果是简单类型，可以直接验证，如果是复杂类，则需要扩展<code>ArgumentMatcher</code>类来做验证。</p>
<p>下面这个方法的逻辑体现在内部调用方法的参数构造上：</p>
<pre><code class="language-cpp">    /**
     * 逻辑体现在参数构造-基本类
     *
     * @param times
     */
    public void bark(int times) {
        int actualTimes = times * 10;
        dog.bark(actualTimes);
    }
</code></pre>
<p>由于参数类型是基本类，所以我们可以直接用verify来验证：</p>
<pre><code class="language-csharp">    //逻辑在参数体现-简单类型
    @Test
    public void bark() {
        doNothing().when(dog).bark(anyInt());
        hangzhouZoo.bark(3);
        verify(dog).bark(30);
        //与上面等价
        verify(dog).bark(eq(30));
    }
</code></pre>
<p>不过如果像下面这样的参数是复杂类的，就需要扩展一下：</p>
<pre><code class="language-dart">     /**
     * 逻辑体现在参数构造-复杂类
     *
     * @param
     * @return
     */
    public String feedVegetable() {
        Food tomato = Food.builder().name(&quot;tomato&quot;).build();
        return dog.eat(tomato);
    }
</code></pre>
<p>自定义参数匹配器：</p>
<pre><code class="language-kotlin">/**
 * @Author: Sawyer
 * @Description: 自定义参数匹配规则
 * @Date: Created in 2:02 PM 2019/10/15
 */

public class ObjectMatcher&lt;T&gt; extends ArgumentMatcher&lt;T&gt; {

    private Object expected;
    private Function&lt;T, Object&gt; getProperty;

    public ObjectMatcher(Object expected, Function&lt;T, Object&gt; getProperty) {
        this.expected = expected;
        this.getProperty = getProperty;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public boolean matches(Object actual) {
        return getProperty.apply((T) actual).equals(expected);
    }
}
</code></pre>
<p>测试的时候使用<code>argThat</code>校验方法参数：</p>
<pre><code class="language-java">    //逻辑在参数体现-复杂类
    @Test
    public void feedVegetable() {
        when(dog.eat(any())).thenReturn(&quot;dog eat&quot;);
        hangzhouZoo.feedVegetable();
        //验证参数
        verify(dog).eat(argThat(new ObjectMatcher&lt;&gt;(&quot;tomato&quot;, Food::getName)));
    }
</code></pre>
<blockquote>
<p>17、单测应在相应的目标方法开发完后立即编写，如能在开发前就开始编写则更好（TDD）。</p>
</blockquote>
<p>解释：这点可能会违背很多开发同学的认知，怎么可能先写单测再写代码呢？实际上，如果稍微了解下测试驱动开发（Test-Driven Development），就会发现这并非异想天开，反倒是顺理成章的事。我认为有两种场景下单测的习惯是很容易能够推动的，第一种是团队里没有测试人员，代码质量完全由开放人员把控；而第二种就是软件开发流程使用的是TDD的方式，这样天然的就保证了单测必须存在。</p>
<p><a href="https://www.jianshu.com/p/37ffeef5ee5b?spm=a2c6h.12873639.0.0.6dea79129hj1We">原文：设计之道－单元测试规范 - 简书 (jianshu.com)</a></p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../tech/bestpractices/禅道工作流.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../tech/bestpractices/数据库自动化-Flyway使用规范.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../tech/bestpractices/禅道工作流.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../tech/bestpractices/数据库自动化-Flyway使用规范.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "tech/bestpractices/单元测试规范.md"
        </script>


        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../assets/custom.js"></script>
        
        <script type="text/javascript" src="../../assets/showBigPicture.js"></script>
        

        

    </body>
</html>